
---
title: "Energy Transitions ‚Äì Winter Semester Seminar"
author: "Renan Magalh√£es"
site: bookdown::bookdown_site
documentclass: book
description: "Course website with classes, code, videos, datasets, and assignments."
---

# Welcome {-}

Welcome to the seminar! This site hosts **all materials**: syllabus, slides, R code, datasets, and weekly exercises.

> Tip: Use the **left sidebar** to navigate across classes and materials.

## How this site is organized

- **Syllabus** with course policies and schedule  
- **Class pages** (Class 01, Class 02, ‚Ä¶) with slides, notes, and code  
- **Assignments** with deadlines and upload links  
- **Datasets** ready to download  
- **About** with contact and credit

To build this site locally, open R and run:

```r
install.packages(c("bookdown", "rmarkdown", "knitr"))
bookdown::render_book("index.Rmd", "bookdown::bs4_book")
```

To publish on GitHub Pages, push the repo and set Pages to serve from the `/docs` folder (see instructions on **About**).

```{r setup, include=FALSE}
# Global setup for all chapters / classes
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
knitr::opts_knit$set(root.dir = here::here())
library(here)
```

<!--chapter:end:index.Rmd-->


# Syllabus {-}

**University:** European University Viadrina  
**Semester:** Winter 2025/26  
**Instructor:** Renan Magalh√£es (<magalhaes@kelso-institute-europe.de>)

## Overview {-}

This seminar introduces basic econometric methods in **R** with hands-on work using the FinSESCo dataset.

## Schedule (tentative) {-}

| Week | Date | Topic |
|-----:|:-----|:------|
| 1 | 2025-10-10 | Course intro, R crash course |
| 2 | 2025-10-17 | Data wrangling (dplyr) |
| 3 | 2025-10-24 | Visualization (ggplot2) |
| 4 | 2025-10-31 | Linear models (lm) |
| 5 | 2025-11-07 | Model diagnostics |
| ‚Ä¶ | ‚Ä¶ | ‚Ä¶ |

## Grading {-}

- Participation: 20%  
- Weekly exercises: 40%  
- Final mini‚Äëproject: 40%

## Policies {-}

- Late work: see **Assignments** page  
- Collaboration: discuss freely; submit your own work

<!--chapter:end:01-syllabus.Rmd-->


---
title: "Energy-Transitions"
pagetitle: "Energy-Transitions ‚Äî Class 1"
author: "Renan Magalh√£es"
output: bookdown::bs4_book
---


# Session 1 {-}

***
## 1. Welcome and Course Overview {-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 01 Recording" frameborder="0" allowfullscreen></iframe>

Welcome to the **Energy Transitions  Seminar**. This course is about learning to *think like a data analyst* in R while working with real data from the energy transition. Each week, we‚Äôll alternate between short explanations and hands-on practice. When you see a new function or concept, try to understand two things: (1) **what** it does, and (2) **why** it‚Äôs the right tool for the job. By the end, you‚Äôll be comfortable loading data, cleaning it, summarizing it, visualizing relationships, and fitting introductory econometric models.

We‚Äôll use the **FinSESCo dataset**, which explores how households behave and invest in energy efficiency.  
Throughout the course you‚Äôll:

- handle real-world data,  
- explore variables,  
- and build econometric models step-by-step.

Everything we do is **hands-on** ‚Äî you‚Äôll code, test, and visualize your own results.

***


### Installing R and RStudio {-}

Download and install:

- [**R**](https://cran.r-project.org/)  
- [**RStudio Desktop**](https://posit.co/download/rstudio-desktop/)

When you open RStudio, you‚Äôll see four panels:

1. **Source** (top-left): scripts or markdown.  
2. **Console** (bottom-left): executes commands.  
3. **Environment / History** (top-right): lists your objects.  
4. **Files / Plots / Packages / Help** (bottom-right): navigation and tools.

![RStudio Interface](images/rstudio_panels.png)

::: {.callout-tip}
#### üí° Tip {-}
RStudio shortcuts speed you up: *Run line* (`Ctrl + Enter`), *Comment/Uncomment* (`Ctrl + Shift + C`), *Find/Replace* (`Ctrl + F`).
:::

***

***

### Installing Packages {-}

R‚Äôs power comes from **packages** ‚Äî sets of functions you add to ‚Äúbase R.‚Äù  
Use `install.packages("name_of_the_package")` **once** per machine to download it, and `library(name_of_the_package)` **each session** to load it.

```{r, eval=FALSE}
install.packages("tidyverse")   # only once
library(tidyverse)              # every session
```

For example, the `tidyverse` bundle gives you: `dplyr` (data manipulation), `ggplot2` (visualization), and `readr` (fast import). You‚Äôll see them often because they standardize syntax and make code readable.

::: {.callout-tip}
#### üí° Tip {-}
If you see an error like `"there is no package called 'dplyr'"`, install it first with `install.packages("dplyr")`, then load it with `library(dplyr)`.
:::


### Working Directory {-}

The **working directory** is the folder R reads from and writes to by default.  
In projects and books, *avoid* `setwd(...)`. Instead, use **project-relative paths** (e.g., via the `here` package) so your code works on any computer without editing file paths.

getwd()  -> shows the current folder
setwd()  -> set your own path

e.g. setwd("C:/Users/Renan/Documents/finsesco_course")


::: {.callout-note}
#### üìù Good practice {-}
Keep a clean structure like `data/`, `images/`, and `scripts/`. Load files with paths such as `here::here("data", "finSESCo_sample.csv")`.
:::



## 2. Variable Assignment & Basic Data Types {-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 01 Recording" frameborder="0" allowfullscreen></iframe>


Everything in R is an **object**. You create or update objects by assignment (prefer the left-arrow `"<-"` because it is idiomatic and visually distinctive). For example, assign a number to `x`, a string to `name`, or a boolean to `sunny`.

```{r}
x <- 30
y <- '50' # character on purpose
name <- "Renan"
sunny <- FALSE
```

R stores values with **types**:
- **numeric** (e.g., `3.14`) for continuous numbers,
- **integer** (e.g., `10L`) for whole numbers,
- **character** (e.g., `"Berlin"`) for text,
- **logical** (`TRUE`/`FALSE`),
- **factor** for labeled categories (internally stored as integers + levels).

You can inspect types with `class(x)` (high-level label) and `typeof(x)` (internal storage).  
You can also convert types with `as.numeric()`, `as.character()`, `as.logical()`, or `as.factor()`. This is called **coercion** and is essential when cleaning survey data that might come in as text.

```{r}
class(x)
class(y)
```
While inspecting the variables, you see that `y` is a character. Therefore you get an error while making operations with it. It is considered a text, not a number as `x`.

```{r, error = TRUE}
x + y
```

```{r}
y_1 <- as.numeric(y)
z <- x + y_1
z
```
Therefore, you should convert `y` as numeric if you want to make operations with `x`.

::: {.callout-tip}
#### üí° Tip {-}
R is **case-sensitive**: `Income` and `income` are different objects. Prefer lower_case_names for names (e.g., `mean_income`).
:::


Try it yourself:

```{r}
temperature <- c(18, 20, 23, 21)
is.numeric(temperature)
```

Type conversion:

```{r}
as.numeric("5")
as.character(123)
as.factor(c("low", "high", "low"))
```



## 3. Working with R Objects {-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 01 Recording" frameborder="0" allowfullscreen></iframe>


R‚Äôs data structures are the building blocks of analysis:

- **Vectors**: one-dimensional, same type. Use `c(...)` to combine values and functions like `length()`, `mean()`, and indexing `[]`.
- **Matrices**: two-dimensional, same type. Useful for linear algebra and certain algorithms; you‚Äôll likely just *recognize* them in Week 1.
- **Factors**: categorical variables with explicit **levels** (e.g., `"low"`, `"medium"`, `"high"`). Factors are crucial for modeling and plotting categories.
- **Data frames**: tables where each column is a vector of the same length. This is your main workhorse for empirical work. Functions like `nrow()`, `names()`, and `str()` help you understand structure.
- **Lists**: containers that can mix types (a model fit often returns a list: coefficients, residuals, fitted values, etc.). Use `$` or `[[ ]]` to access elements.

The **tidyverse** elevates data frames into **tibbles**, which print nicely and behave consistently.


```{r, echo=FALSE}
### Data Type Overview

# Create a data frame describing R's basic data types
data_types <- data.frame(
  Type = c("Numeric", "Integer", "Character", "Logical", "Factor"),
  Example = c("3.14", "10L", "\"Berlin\"", "TRUE, FALSE", "factor(c('Low','High'))"),
  Description = c(
    "Real or decimal numbers",
    "Whole numbers",
    "Text strings",
    "Boolean values",
    "Categorical (labeled) data"
  )
)

# Display the table nicely
knitr::kable(data_types, caption = "Basic Data Types in R")
```


### i) Vectors {-}

A **vector** is a one-dimensional collection of elements of the **same type**. Vectors are the fundamental building block of R.

```{r}
# Creating numeric, character, and logical vectors
v_num  <- c(10, 20, 30, 40)
v_chr  <- c("east", "west", "north")
v_log  <- c(TRUE, FALSE, TRUE)
```

```{r}
v_num
v_chr
v_log
```

You can access elements by **position** (1-based indexing) and perform **vectorized operations**:

```{r}
# Indexing (1-based)
v_num[1]          # first element
v_num[2:3]        # elements 2 through 3
v_num[c(1, 4)]    # elements 1 and 4
```

```{r}
# Vectorized math
v_num + 5
v_num * 2
v_num / v_num     # element-wise division
```

### ii) Matrices {-}

A matrix is a 2D collection (rows √ó columns) of the same type.

```{r}
m <- matrix(1:9, nrow = 3, byrow = TRUE)
m
m[2, 3]     # element in row 2, column 3
```

### iii) Factors {-}

Factors represent categorical variables (with levels).

```{r}
gender <- factor(c("Male", "Female", "Female"))
levels(gender)
table(gender)

```

### iv) Data Frames {-}

A data frame is a table where each column is a vector of equal length.

```{r}
df <- data.frame(
  id = 1:3,
  income = c(2000, 3500, 2800),
  region = c("East", "West", "West")
)
head(df)
str(df)
```


```{r}
###Basic subsetting:

df$income
df[ , "region"]
df[ df$income > 2500, ]
```


### v) Lists {-}

A list can store elements of different types (useful for model results).

```{r}
person <- list(
  name = "Renan",
  age = 31,
  instruments = c("Guitar", "Bass")
)
person$instruments
person[[1]]      # first element of the list
```


## 4. Exploring Your Dataset {-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 01 Recording" frameborder="0" allowfullscreen></iframe>


Let‚Äôs import the FinSESCo dataset
(Once you‚Äôve downloaded the `.csv` file from the course repository.)

```{r, message=FALSE}
finsesco <- read_csv(here::here("data", "finSESCo_sample.csv"))
```

In our seminar, we‚Äôll analyze a curated sample of the **FinSESCo** survey. This dataset was collected by the survey company **Norstat** between **28 Aug 2023** and **23 Nov 2023** to study **energy-efficiency behaviors**, **demand-side flexibility**, and **(co-)ownership** patterns among German households. The design intentionally broadened the representation of **female** and **low-income** prosumers relative to earlier waves, aiming for a more balanced view across demographics. While the panel sampling approach means national proportions of prosumers cannot be inferred, the survey targeted representativeness by **age**, **gender**, and **state population distributions**, with adjustments later in fieldwork to reach specific groups of interest. :contentReference[oaicite:0]{index=0}

**Sample size:** 2,585 completed questionnaires  
**Prosumers:** 925 individuals (including 464 women)  
This scale enables comparisons between prosumers and non-prosumers and within prosumer subgroups (e.g., by income and gender). :contentReference[oaicite:1]{index=1}

**Key constructs & questions we‚Äôll use later:**
- **Willingness to invest** in electricity/heating efficiency measures (past actions score + planned actions score).
- **Familiarity with Energy Savings (Performance) Contracting** and **intention to use** a FinSESCo-like platform (transformed from ‚Äì3‚Ä¶+3 into analytical indices).
- **Drivers** (motivations such as financial, environmental, knowledge, climate concern, energy autonomy, selling excess energy) on Likert scales.
- **Context & demographics**: (co-)ownership, income category, age, gender, education, and more. :contentReference[oaicite:2]{index=2}


When you import tabular data, always **sanity-check**:
- **Preview** the first rows (does it look like a clean table?).
- **Structure**: variable names, types (numeric? character? factor?).
- **Missing values**: how many and where?
- **Ranges**: do minima/maxima make sense?

In R, you‚Äôll use functions like `head()`, `str()`, `summary()`, and `dplyr::glimpse()` for an overview.  
For survey data, expect **missing values** (`NA`). Many functions accept `na.rm = TRUE` to compute summaries on the observed values only. If you forget it, a single `NA` can make a whole summary become `NA`.

::: {.callout-important}
#### üî¥ Important {-}
A variable might *look* numeric but be stored as **character** (e.g., due to non-standard entries). Check with `class()` and coerce thoughtfully with `as.numeric()` after cleaning.
:::


Start by exploring the structure:
```{r}
head(finsesco)
str(finsesco)
glimpse(finsesco)
summary(finsesco)
```

You‚Äôll get a sense of the variables ‚Äî maybe `income_range`, `age`, `education`, etc.

üí° **Tip**: When you see NA, it means ‚Äúmissing data.‚Äù You can remove or ignore them with na.rm = TRUE in most functions.


## 5. Descriptive Statistics {-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 01 Recording" frameborder="0" allowfullscreen></iframe>



Descriptive statistics tell you what your data looks like before modeling:
- **Central tendency**: `mean()` and `median()` (median is robust to outliers).
- **Spread**: `sd()` (standard deviation) and interquartile range.
- **Distribution shape**: histograms and boxplots to detect skewness and outliers.
- **Counts and proportions**: `table()` for factors; grouped summaries for categories.

With `dplyr`, the flow is:  
**group** ‚Üí **summarise** ‚Üí **arrange** (optionally **mutate** to compute new columns).  
For example, you might compute the **average energy spending** by **income group** or the **share of respondents** who report a specific behavior by **ownership type**‚Äîthese are the first steps toward answering research questions.

::: {.callout-note}
#### üìù Interpretation mindset
When two groups differ in means, ask: *Is this difference large enough to matter? Stable across subgroups? Driven by outliers?* Plotting complements tables by revealing distribution shape and potential leverage points.
:::


Let‚Äôs compute some simple summaries.

```{r}
mean(finsesco$index_1, na.rm = TRUE)
median(finsesco$index_1, na.rm = TRUE)
sd(finsesco$index_1, na.rm = TRUE)

```

Using `dplyr`, we can do this by group:

```{r}
finsesco %>%
  group_by(income_range) %>%
  summarise(mean_index_1 = mean(index_1, na.rm = TRUE))
```

### Your First Plot {-}

Plots are compact summaries. In Week 1, we mainly use:
- **Histogram** (one numeric variable): distribution, skew, possible heaping.
- **Boxplot** (numeric vs. category): medians, spread, and outliers across groups.
- **Bar chart** (counts or summary statistics): proportions or aggregated metrics across categories.

In later weeks, we‚Äôll refine these by adding confidence intervals, transforming axes (e.g., log scale), and layering multiple aesthetics to compare subgroups (e.g., income by ownership).

We‚Äôll use `ggplot2` (included in `tidyverse`) to visualize the relationship between income group and `index_1`, that calculates the willingness to invest in energy efficiency measures.


```{r}
ggplot(finsesco, aes(x = income_range, y = index_1)) +
  geom_boxplot() +
  labs(
    title = "Willingness to invest in Energy Efficiency Measures by Income Group",
    x = "Income Group",
    y = "Index 1"
  )
```

üí° **Try This**:
Change the variable on the y-axis to another numeric column and see how the plot changes!


## Exercise {-}

- **Exercise 01**: **[download Rmd](exercises/ex01/ex01.Rmd)**  
- Upload via **Assignments** page on Moodle.

<!--chapter:end:02-class-01.Rmd-->


---
title: "Energy-Transitions"
pagetitle: "Energy-Transitions ‚Äî Class 2"
author: "Renan Magalh√£es"
output: bookdown::bs4_book
---



# Session 2 {-}

***
## 1. Why Data Cleaning Is the Hardest (and Most Important) Step{-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 02 Recording" frameborder="0" allowfullscreen></iframe>

When researchers talk about ‚Äúanalysis,‚Äù they often imagine fancy models and colorful plots.
In reality, most of the work happens before any model is fitted: cleaning, organizing, and validating the raw data. Raw data are almost never ready for analysis. Surveys come back with extra spaces, numbers formatted as text, spelling variations, and missing responses.
If you skip the cleaning stage, every later step‚Äîsummary statistics, regression, visualization‚Äîwill quietly give misleading results.

**What ‚Äútidy‚Äù means**

Hadley Wickham defines tidy data as having three rules:

*1.*Each variable forms a column.
*2.*Each observation forms a row.
*3.*Each value forms a single cell.

Once data satisfy these rules, they can easily be filtered, summarized, plotted, and joined.
Most R packages (especially those in the tidyverse) assume data are tidy.
The cleaning workflow we‚Äôll follow mirrors the professional pipeline:



```{r echo = FALSE}

library(gt)

workflow <- data.frame(
  Step = c("Import", "Inspect", "Clean names/types", "Handle missingness",
           "Recode", "Verify visually", "Save"),
  Goal = c("Load raw data reliably",
           "Understand structure",
           "Make columns usable",
           "Make absence explicit",
           "Create consistent categories",
           "Sanity-check patterns",
           "Freeze a clean version"),
  Example_Functions = c("read_csv()",
                        "glimpse(), summary()",
                        "janitor::clean_names(), mutate()",
                        "is.na(), if_else()",
                        "case_when(), fct_recode()",
                        "ggplot()",
                        "write_csv()")
)

workflow |>
  gt() |>
  tab_header(
    title = "Data Cleaning Workflow in R"
  ) |>
  cols_label(
    Step = "Step",
    Goal = "Goal",
    Example_Functions = "Example Functions"
  ) |>
  fmt_markdown(columns = everything())
```


## 2. Importing and Inspecting the Dataset{-}

We‚Äôll use the same FinSESCo survey introduced in Session 1.
This time we‚Äôll pay close attention to its structure, not yet to its content.


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
finsesco <- read_csv(here::here("data", "finsesco_dirt.csv"))
```


**How R reads files**

`read_csv()` (from readr) is faster and safer than base R‚Äôs `read.csv()`:

- It assumes UTF-8 encoding (so German umlauts, ‚Ç¨ signs, etc. remain intact).
- It guesses data types by scanning a sample of rows.
- It reports parsing problems instead of silently converting to text.

`here::here()` constructs file paths relative to your R Project root, which makes your script portable between computers and operating systems.


Now look inside:

```{r}
glimpse(finsesco)
summary(finsesco)
```

`glimpse()` prints one line per variable, showing type and first values; `summary()` gives numeric summaries or category counts.


Rows: 2,585
Columns: 45
$ Age                <chr> "32", "45", "63", "28", ‚Ä¶
$ Income Range (‚Ç¨)   <chr> "2,500‚Äì4,000", "4,000‚Äì6,000", ‚Ä¶
$ Gender             <chr> "Female", "Male", ‚Ä¶


You can already you spot issues:

- `Age` is stored as character, not numeric.
- Column !!!!! contain spaces and symbols.
- There are multiple inconsistent formats for `income`.

Before cleaning, it helps to know what R thinks each type means:

```{r echo=FALSE, message=FALSE, warning=FALSE}

library(gt)
library(tibble)

types <- tibble(
  `R Type` = c("character", "numeric", "integer", "factor", "logical"),
  `What It Represents` = c("text", "decimal numbers", "whole numbers", "categorical labels", "TRUE/FALSE flags"),
  `Common Problems` = c("numbers read as text", "missing decimals ‚Üí integers", "rarely a problem", "wrong order or encoding", "blanks become NA")
)

types |>
  gt() |>
  tab_header(title = "Overview of R Data Types")
```



Check data types with `sapply(finsesco, class)` if you‚Äôre unsure.

::: {.callout-tip}

üí° Tip {-}

R‚Äôs type system is strict: `"42"` (character) is not the same as `42` (numeric).
Whenever arithmetic fails, first check the variable‚Äôs type.
:::


## 3. Cleaning Column Names and Correcting Types{-}


**Why clean names?**

Messy names make scripts fragile. Every time you use spaces or special characters, you have to surround the name with backticks, e.g. `Income Range (‚Ç¨)`.
`janitor::clean_names()` automatically fixes this by converting all names to lower_snake_case and stripping illegal characters.



```{r  message=FALSE, warning=FALSE}
library(janitor)

finsesco <- finsesco %>%
  clean_names() %>%
  mutate(age = as.integer(age),income_range = as.factor(income_range))

```


**Step-by-step explanation**

- `clean_names()` renames columns like `Income Range (‚Ç¨)` ‚Üí `income_range_eur`. It also ensures uniqueness‚Äîif two columns share the same label, it appends _2, _3, etc.
- `mutate()` lets us change columns in-place.
- `as.integer(age)` converts character digits into true numbers.
- `as.factor(income_range)` tells R this is a categorical variable.

Re-inspect:


```{r}
glimpse(finsesco)
```

If you now see age: int and income_range: fct, the cleaning worked.

::: {.callout-important}

üî¥ Important {-}

`as.numeric()` and `as.integer()` silently turn non-convertible text into `NA`.
Always check how many missing values you introduced: `sum(is.na(finsesco$age))`

:::


## 4. The Logic of Pipes and dplyr Verbs{-}

<iframe width="720" height="405" src="https://www.youtube.com/embed/dQw4w9WgXcQ" title="Class 02 Recording" frameborder="0" allowfullscreen></iframe>

The pipe operator `%>%` passes the output of one function as the first argument of the next. This creates readable ‚Äúsentences‚Äù of code.

Example without pipes:

`summarise(group_by(finsesco, income_range),
          mean(index_1, na.rm = TRUE))`


Example with pipes:

```{r}
finsesco %>%
  group_by(income_range) %>%
  summarise(mean_index_1 = mean(index_1, na.rm = TRUE))
```

The second version mirrors human thought: take data ‚Üí group ‚Üí summarise.

```{r echo=FALSE, message=FALSE, warning=FALSE}

library(gt)
library(tibble)

verbs <- tibble(
  Verb = c(
    "select()",
    "filter()",
    "mutate()",
    "arrange()",
    "summarise() + group_by()"
  ),
  `What it does` = c(
    "choose columns",
    "choose rows",
    "add/modify columns",
    "reorder rows",
    "aggregate groups"
  ),
  Analogy = c(
    "decide which questions to keep",
    "choose which participants to include",
    "compute new variables",
    "sort by value",
    "compute averages per category"
  )
)

verbs |>
  gt() |>
  tab_header(title = "The Five Essential dplyr Verbs") |>
  cols_label(
    Verb = "Verb",
    `What it does` = "What It Does",
    Analogy = "Analogy"
  )
```



Let‚Äôs apply them:


```{r}
mini <- finsesco %>%
  select(age, gender, income_range, index_1) %>%
  filter(!is.na(index_1)) %>%
  mutate(high_invest_intent = index_1 >= quantile(index_1, 0.75, na.rm = TRUE)) %>%
  arrange(desc(index_1))
```

Explanation:

- `select()` keeps only relevant variables.
- `filter(!is.na(index_1))` removes incomplete responses.
- `quantile(index_1, 0.75)` finds the top 25 % cutoff.
- `mutate()` creates a logical variable (TRUE/FALSE) indicating whether each person is in that top quartile.
- `arrange()` orders the dataset so the highest scores appear first.

```{r}
head(mini)
```

Now you can see the structure: a concise, consistent table for further analysis.


If you want to know all the other verbs from `dplyr`, you can download a *cheat sheet*, that serves as a manual for using it.

[üìÑ Download the *dplyr Cheat Sheet* (PDF)](https://media.datacamp.com/legacy/image/upload/v1660300796/Marketing/Blog/Manipulating_Data_in_dplyr_Cheat_Sheet.pdf)


## 5. Grouping, Summarizing, and Interpreting {-}

Aggregating data is the first step toward understanding patterns.


```{r}
mini %>%
  group_by(income_range) %>%
  summarise(n = n(), 
            mean_index_1 = mean(index_1, na.rm = TRUE),
            sd_index_1 = sd(index_1, na.rm = TRUE),
            share_high = mean(high_invest_intent))
```

- `group_by()` adds a ‚Äúgrouping‚Äù attribute without changing the data itself.
- `summarise()` collapses each group to one row by computing summary statistics.
- Because TRUE = 1 and FALSE = 0, `mean(high_invest_intent)` automatically yields the proportion of TRUEs.

Interpretation example:

Higher-income respondents show higher mean `index_1` and a larger share of high-intention investors, suggesting economic capacity plays a role in willingness to invest.

**Be careful:** these are descriptive patterns, not causal effects!
We haven‚Äôt yet controlled for age, ownership, education or other variables.



## 6. Recoding and Creating Ordered Factors {-}

Categorical variables should have intuitive labels and logical order.

Re-labeling income groups

```{r  message=FALSE, warning=FALSE}
finsesco <- finsesco %>%
  mutate(
  income_range = fct_recode(income_range,
  "Low" = "Under ‚Ç¨1,500",
  "Middle" = "‚Ç¨1,500‚Äì‚Ç¨4,000",
  "High" = "Over ‚Ç¨4,000") %>% 
  fct_relevel("Low","Middle","High")
)
```


- `fct_recode()` maps old labels to shorter ones.
- `fct_relevel()` defines the order used in plots and summaries.
- Without re-leveling, R might sort alphabetically, putting ‚ÄúMiddle‚Äù before ‚ÄúLow‚Äù.

Creating age groups


```{r}
finsesco <- finsesco %>%
  mutate(
  age_group = case_when(
  age < 30 ~ "18‚Äì29",
  age < 45 ~ "30‚Äì44",
  age < 60 ~ "45‚Äì59",
  age >= 60 ~ "60+",
  TRUE ~ NA_character_) %>%
  factor(levels = c("18‚Äì29","30‚Äì44","45‚Äì59","60+"))
)
```

- `case_when()` checks each condition sequentially.
- The pipe into `factor()` turns the string labels into an ordered categorical variable, ensuring that 18‚Äì29 appears before 30‚Äì44 in graphs.

Why this matters: statistical models interpret factors based on their order‚Äîby defining it explicitly, you avoid misleading reference levels later.


## 7. Saving and Versioning Clean Data {-}

Never overwrite the raw file. Always save a new one that documents its lineage.

```{r}
clean <- finsesco %>%
  select(age, age_group, gender,
  income_range, index_1)
```


```{r}
write_csv(clean, here::here("data", "finsesco_clean.csv"))
```

This becomes the baseline for all later sessions.
If you later discover an error, you can regenerate the file from the same script rather than editing data manually.


## 8. Conceptual Reflection {-}

Cleaning data is not busywork‚Äîit‚Äôs modeling reality.
When you decide that ‚Äúunder ‚Ç¨1,500‚Äù means ‚ÄúLow-Income‚Äù you‚Äôre interpreting social categories. When you replace a missing `index_1` by the median, you‚Äôre making an assumption about the underlying distribution. Recognizing these choices makes you a transparent analyst.










<!--chapter:end:03-class-02.Rmd-->

# Session 3 {-}

## Visualization with ggplot2 {-}

<!--chapter:end:04-class-03.Rmd-->

# Session 4 {-}

<!--chapter:end:05-class-04.Rmd-->

# Session 5 {-}

<!--chapter:end:06-class-05.Rmd-->


# Assignments & Uploads {-}

<!--chapter:end:90-assignments.Rmd-->


# Datasets {-}

Place your data files in the `data/` folder. Use links below so students can download:

- **finSESCo_sample.csv** ‚Äì [Download](data/finSESCo_sample.csv)  
- **energy_usage_demo.csv** ‚Äì [Download](data/energy_usage_demo.csv)

```{r}
# Small preview example
data <- read.csv("data/energy_usage_demo.csv")
head(data)
```

<!--chapter:end:91-datasets.Rmd-->


# About & Publishing {-}

## Contact

- **Instructor:** Renan Magalh√£es  
- **Email:** <magalhaes@kelso-institute-europe.de>

## Credits

Built with **bookdown::bs4_book**.

<!--chapter:end:92-about.Rmd-->

